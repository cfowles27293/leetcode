import math
from sympy import isprime, mod_inverse

def open_file(file):
    try:
        with open(file) as f:
            data = f.readlines()
            c = data[1]
            value_c = ''.join(x for x in c if x.isdigit())
            n = data[2]
            value_n = ''.join(x for x in n if x.isdigit())
            e = data[3]
            value_e = ''.join(x for x in e if x.isdigit()) # e is 2^16 - 1
            # print(factor(value_n))
            '''
            p and q were obtained from FactorDB
            Factoring would take several days otherwise. 
            '''
            p = 2434792384523484381583634042478415057961
            q = 650809615742055581459820253356987396346063
            print(bytes.fromhex(hex(decrypt(int(value_c), int(value_n), int(value_e), p, q))[2:]).decode('ascii'))


    except Exception as e:
        print(e)

'''RSA notes:
    e is chosen such that 1 < e < totient(n) and e is coprime with totient(n)
    n is the product of distinct primes p & q, totient(n) is the totient function of p & q
    c is the ciphertext
    
    d and lambda(n) are kept private, they allow decryption. 
        d = e^-1 % totient(n)
        totient(n) = lcm((p-1)(q-1))
        
    m^e = c % mod n (encryption)
    c^d = m^(ed) = m % n (decryption)
'''

def factor(n) -> list:
    factors = []
    n= int(n)
    sqrt_n = round(math.sqrt(n))
    for p in range(sqrt_n):
        if isprime(p):
            q = n/p
            if (q).is_integer() and isprime(q):
                factors.append([p,q])

def lcm(a, b):
    return abs(a*b) // math.gcd(a, b)

def decrypt(c, n, e, p, q):
    m = ''
    totient_n = lcm((p-1),(q-1))
    d = mod_inverse(e, totient_n)
    m = pow(c, d, n)
    return m


open_file('C://Users//craig//Downloads//values')